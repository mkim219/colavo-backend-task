# 의존성 주입(DI)을 사용하지 않을 때의 단점

## 1. 테스트의 어려움
- 컨트롤러 내부에서 직접 서비스를 생성하면, 테스트 시 실제 서비스를 대체하기 어려움
- 단위 테스트에서 가짜(mock) 객체를 주입하기 어려워, 통합 테스트만 가능

```typescript
// 현재 방식으로는 이런 테스트가 불가능
const mockService = { generateTimeSlots: jest.fn() };
const controller = new TimeslotController(mockService);
```

## 2. 강한 결합도 (Tight Coupling)
- 컨트롤러가 특정 서비스 구현에 직접적으로 의존
- 서비스 구현을 변경하거나 다른 구현으로 교체하기 어려움

```typescript
// 현재는 이렇게 강하게 결합되어 있음
this.timeslotService = new TimeslotService();
```

## 3. 단일 책임 원칙 위반
- 컨트롤러가 자신의 주요 책임(요청 처리) 외에도 의존성 생성의 책임을 가짐
- SOLID 원칙 중 단일 책임 원칙(SRP) 위반
- 클래스가 변경되어야 하는 이유가 여러 가지가 됨

## 4. 코드 재사용성 감소
- 다른 구현체나 설정으로 컨트롤러를 재사용하기 어려움
- 테스트 환경이나 개발 환경에서 다른 서비스 구현을 사용하기 어려움
- 동일한 컨트롤러를 다른 컨텍스트에서 재사용하기 힘듦

## 5. 확장성 제한
- 새로운 기능이나 요구사항 추가 시 코드 변경이 더 어려움
- 로깅, 캐싱 등의 기능을 추가하려면 컨트롤러 코드를 직접 수정해야 함
- 기존 코드를 수정해야 하므로 OCP(Open-Closed Principle) 위반

## 6. 설정의 유연성 부족
```typescript
// 현재 방식
constructor() {
  this.timeslotService = new TimeslotService(); // 하드코딩된 의존성
}

// 필요한 경우 다른 설정을 주입하기 어려움
// 예: 다른 시간대, 다른 비즈니스 규칙 등
```

## 7. 런타임 동작 변경의 어려움
- 애플리케이션 실행 중에 서비스의 동작을 동적으로 변경하기 어려움
- A/B 테스팅이나 피처 플래그 구현이 복잡해짐
- 동적 설정 변경이나 런타임 시 다른 구현체로 전환이 어려움

## 8. 코드 유지보수의 어려움
- 의존성이 코드 내부에 하드코딩되어 있어, 변경 시 여러 곳을 수정해야 함
- 버그 발생 가능성 증가
- 유지보수 비용 증가
- 코드 변경의 영향도 파악이 어려움

## 결론
이러한 단점들은 프로젝트가 커질수록 더 큰 문제가 됩니다. 특히 마이크로서비스 아키텍처나 대규모 애플리케이션에서는 의존성 주입의 부재가 심각한 제약이 될 수 있습니다. 따라서 초기 설계 단계에서부터 의존성 주입을 고려하는 것이 바람직합니다. 